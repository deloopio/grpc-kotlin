@file:Suppress("EXPERIMENTAL_API_USAGE")

{{#packageName}}
package {{packageName}}
{{/packageName}}

import {{packageName}}.{{serviceName}}Grpc.*

import io.grpc.*
import io.grpc.stub.*
import io.rouz.grpc.*

import kotlin.coroutines.*
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.*

{{#javaDoc}}{{{javaDoc}}}{{/javaDoc}}
{{#deprecated}}@Deprecated("deprecated"){{/deprecated}}
@javax.annotation.Generated(
    value = ["by gRPC Kotlin generator"],
    comments = "Source: {{protoName}}"
)
abstract class {{serviceName}}ImplBase(
    context: CoroutineContext = Dispatchers.Default
) : {{serviceName}}Grpc.{{serviceName}}ImplBase() {

    private val coroutineScope = object : CoroutineScope {
      override val coroutineContext: CoroutineContext
         get() = context
    }

    {{#methods}}
    {{#javaDoc}}{{{javaDoc}}}{{/javaDoc}}
    {{#deprecated}}@Deprecated("deprecated"){{/deprecated}}
    {{^isManyInput}}
    {{^isManyOutput}}
    {{! == unary req, unary resp == }}
    open suspend fun {{methodName}}(request: {{inputType}}): {{outputType}} {
        throw unimplemented(get{{methodNamePascalCase}}Method()).asRuntimeException()
    }

    final override fun {{methodName}}(request: {{inputType}}, responseObserver: StreamObserver<{{outputType}}>) {
        coroutineScope.launch(GrpcContextCoroutineContextElement()) {
            this.doCancelScopeWhenGrpcContextCancelled()
            tryCatchingStatus(responseObserver) {
                val response = {{methodName}}(request)
                onNext(response)
            }
        }
    }

    {{/isManyOutput}}
    {{#isManyOutput}}
    {{! == unary req, streaming resp == }}
    open fun {{methodName}}(request: {{inputType}}, produceScope: ProducerScope<{{outputType}}>) {
        throw unimplemented(get{{methodNamePascalCase}}Method()).asRuntimeException()
    }

    final override fun {{methodName}}(request: {{inputType}}, responseObserver: StreamObserver<{{outputType}}>) {
        coroutineScope.launch(GrpcContextCoroutineContextElement()) {
            this.doCancelScopeWhenGrpcContextCancelled()
            tryCatchingStatus(responseObserver) {
                produce<{{outputType}}> { {{methodName}}(request, this) }
                  .consumeEach(::onNext)
            }
        }
    }
    {{/isManyOutput}}
    {{/isManyInput}}
    {{#isManyInput}}
    {{^isManyOutput}}
    {{! == streaming req, unary resp == }}
    open suspend fun {{methodName}}(requests: ReceiveChannel<{{inputType}}>): {{outputType}} {
        throw unimplemented(get{{methodNamePascalCase}}Method()).asRuntimeException()
    }

    internal fun {{methodName}}Internal(
        responseObserver: StreamObserver<{{outputType}}>
    ): StreamObserver<{{inputType}}> {
        val requests = StreamObserverChannel<{{inputType}}>()
        coroutineScope.launch(GrpcContextCoroutineContextElement()) {
            this.doCancelScopeWhenGrpcContextCancelled()
            tryCatchingStatus(responseObserver) {
                val response = {{methodName}}(requests)
                onNext(response)
            }
        }
        return requests
    }
    {{/isManyOutput}}
    {{#isManyOutput}}
    {{! == streaming req, streaming resp == }}
    open fun {{methodName}}(requests: ReceiveChannel<{{inputType}}>): ReceiveChannel<{{outputType}}> {
        throw unimplemented(get{{methodNamePascalCase}}Method()).asRuntimeException()
    }

    internal fun {{methodName}}Internal(
        responseObserver: StreamObserver<{{outputType}}>
    ): StreamObserver<{{inputType}}> {
        val requests = StreamObserverChannel<{{inputType}}>()
        coroutineScope.launch(GrpcContextCoroutineContextElement()) {
            this.doCancelScopeWhenGrpcContextCancelled()
            tryCatchingStatus(responseObserver) {
                val responses = {{methodName}}(requests)
                for (response in responses) {
                    onNext(response)
                }
            }
        }
        return requests
    }
    {{/isManyOutput}}
    {{/isManyInput}}
    {{/methods}}

    private fun unimplemented(methodDescriptor: MethodDescriptor<*, *>): Status {
        return Status.UNIMPLEMENTED
            .withDescription("Method ${methodDescriptor.fullMethodName} is unimplemented")
    }

    private fun <E> handleException(t: Throwable?, responseObserver: StreamObserver<E>) {
        when (t) {
            null -> return
            is CancellationException -> handleException(t.cause, responseObserver)
            is StatusException, is StatusRuntimeException -> responseObserver.onError(t)
            is RuntimeException -> {
                responseObserver.onError(Status.UNKNOWN.asRuntimeException())
                throw t
            }
            is Exception -> {
                responseObserver.onError(Status.UNKNOWN.asException())
                throw t
            }
            else -> {
                responseObserver.onError(Status.INTERNAL.asException())
                throw t
            }
        }
    }

    private suspend fun <E> tryCatchingStatus(responseObserver: StreamObserver<E>, body: suspend StreamObserver<E>.() -> Unit) {
        try {
            responseObserver.body()
            responseObserver.onCompleted()
        } catch (t: Throwable) {
            handleException(t, responseObserver)
        }
    }
}

private fun CoroutineScope.doCancelScopeWhenGrpcContextCancelled() {
  val onGrpcContextCancelled: (Context) -> Unit = {
    cancel(CancellationException("Grpc context cancelled"))
  }
  Context.current().addListener(onGrpcContextCancelled, Runnable::run)
}
